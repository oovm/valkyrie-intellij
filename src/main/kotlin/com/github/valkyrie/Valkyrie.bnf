{
    parserClass = "com.github.valkyrie.language.parser.ValkyrieParser"
    parserUtilClass = "com.github.valkyrie.language.psi.ValkyrieParserExtension"

    extends = "com.github.valkyrie.language.ast.ValkyrieASTBase"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.valkyrie.language.psi"
    psiImplPackage = "com.github.valkyrie.language.psi_node"

    elementTypeHolderClass = "com.github.valkyrie.language.psi.ValkyrieTypes"
    elementTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"
    tokenTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"

    psiImplUtilClass = "com.github.valkyrie.language.ast.ASTMethods"
    generateTokenAccessors = false

    tokens = [
        COMMENT = "Comment"
        // literal
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        STRING_START = "StringStart"
        STRING_TEXT = "StringText"
        STRING_END = "StringEnd"
        BYTE = "Byte"

        DOT = '.'
        SEMICOLON = ';'
        COLON = ':'
        PROPORTION = "::"

        OP_INC = "++"
        OP_ADD_ASSIGN = "+="
        OP_ADD = "+"
        OP_DEC = "--"
        OP_SUB_ASSIGN = "-="
        OP_SUB = "-"
        OP_MUL_ASSIGN = "*="
        OP_MUL = "*"
        OP_DIV_ASSIGN = "/="
        OP_DIV = "/"
        OP_MOD_ASSIGN = "%="
        OP_MOD = "%"

        OP_AND_ASSIGN = "&="
        OP_AND = "&"
        OP_AND2 = "&&"
        OP_OR_ASSIGN = "|="
        OP_OR = "|"
        OP_OR2 = "||"
        OP_POW = "^"
        // DOTS
        OP_ARROW = "->"
        OP_ARROW2 = "=>"
        //
        OP_EQ = "="
        OP_NE = "!="
        OP_BIND = ":="
        OP_NOT = "!"
        //
        OP_GT = ">"
        OP_GS = "/>"
        OP_GG = ">>"
        OP_GEQ = ">="
        OP_GGG = ">>>"
        //
        OP_LT = "<"
        OP_LS = "</"
        OP_LL = "<<"
        OP_LEQ = "<="
        OP_LLL = "<<<"
        OP_EMPTY = "(!)"

        OP_IS_A = "is"
        OP_NOT_A = "is not"

        OP_IN = "in"
        OP_NOT_IN = "not_in"
        OP_AND_THEN = "and_then"
        OP_OR_ELSE = "or_else"
        OP_FORALL = "forall"
        OP_EXISTS = "exists"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        GENERIC_L = '::<'
        GENERIC_R = '>::'

//        KW_NAMESPACE = "namespace"
//        KW_IMPORT = "using"
//        KW_EXTENSION = "extension"
//        KW_AS = "as"
//
//        KW_LET = "let"
//        KW_DEFINE = "def"
//        KW_NEW = 'new'
//
//        KW_IF = "if"
//        KW_ELSE = "else"
//        KW_FOR = "for"
//        KW_WHILE = "while"
//        KW_MATCH = 'match'
//        KW_CATCH = 'catch'
//
//        KW_CLASS = 'class'
//        KW_TRAIT = 'trait'
//        KW_TAGGED = 'tagged'
//        KW_BITFLAG = 'bitset'
//        KW_EXTENDS = 'extends'
    ]
}

valkyrie ::= ((normal_statements|top_statements) [SEMICOLON])*
private top_statements ::=
    namespace_statement
  | import_statement
  | extension_statement
  | class_statement
  | trait_statement
  | tagged_statement
  | bitflag_statement
  | extends_statement
  | new_statement
  | SEMICOLON
  ;
private normal_statements ::=
    if_statement
  | for_statement
  | while_statement
  | match_statement
  | let_statement
  | define_statement
  | type_statement
  | forall_statement
//  | macro_list
//  | macro_call
  | expression
  ;
// ---------------------------------------------------------------------------------------------------------------------
namespace_statement ::= KW_NAMESPACE namespace_dot {
    mixin="com.github.valkyrie.language.mixin.MixinNamespace"
};
namespace_dot    ::= identifier (may_dot identifier)*;
may_dot          ::= DOT | PROPORTION;
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= KW_IMPORT (import_block|import_item)
import_item      ::= namespace_dot [KW_AS identifier|may_dot import_block] {
    mixin="com.github.valkyrie.language.mixin.MixinImportItem"
}
import_block     ::= <<brace_block import_item COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
extension_statement ::= KW_EXTENSION identifier COLON namespace_dot top_block {
    mixin="com.github.valkyrie.language.mixin.MixinExtension"
};
top_block        ::= <<brace_block top_statements SEMICOLON>>
// ---------------------------------------------------------------------------------------------------------------------
if_statement     ::= (IF condition block) [ef_statement* [else_statement]]
ef_statement     ::= else_if condition block;
private else_if  ::= ELSE IF
else_statement   ::= ELSE block;
condition        ::= case_pattern BIND expression | expression;
case_pattern     ::= CASE [identifier* [namespace]] pattern;
private block    ::= <<brace_block expression SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
for_statement    ::= FOR (case_pattern|normal_pattern) IN expression [if_guard] block [else_statement];
if_guard         ::= IF condition;
normal_pattern   ::= identifier* pattern | <<sequence pattern_item COMMA>> {
    mixin="com.github.valkyrie.language.mixin.MixinNormalPattern"
};
// ---------------------------------------------------------------------------------------------------------------------
private pattern  ::=
    <<parenthesis   pattern_pair COMMA>>
  | <<bracket_block pattern_pair COMMA>>
  | <<brace_block   pattern_pair COMMA>>
  ;
pattern_pair     ::= identifier* COLON pattern_value | identifier* (DOT3|DOT2) identifier | identifier+;
pattern_item     ::= identifier* (DOT3|DOT2) identifier | identifier+;
pattern_value    ::= identifier | pattern;
// ---------------------------------------------------------------------------------------------------------------------
while_statement  ::= WHILE condition block;
// ---------------------------------------------------------------------------------------------------------------------
match_statement  ::= MATCH identifier* match_block;
match_block      ::= <<brace_block match_expression SEMICOLON>>;
match_expression ::= case_pattern COLON (normal_statements [SEMICOLON])+
// ---------------------------------------------------------------------------------------------------------------------
define_statement ::= kw_define [modifiers] namespace_dot [type_angle] define_tuple [(COLON|OP_ARROW) type_expression] [define_block| OP_EQ expression] {
    mixin="com.github.valkyrie.language.mixin.MixinDefine"
};
kw_define        ::= "def"
define_item      ::= OP_POW | ANGLE_L | ANGLE_R | [modifiers] identifier [(DOT2|DOT3) identifier] [COLON type_expression] [OP_EQ expression] {
    mixin="com.github.valkyrie.language.mixin.MixinDefineItem"
}
modifiers        ::= (identifier !(PARENTHESIS_L|DOT|SEMICOLON|PROPORTION))+ {
    mixin="com.github.valkyrie.language.mixin.MixinModifier"
};
define_tuple     ::= <<parenthesis define_item COMMA>>;
define_block     ::= <<brace_block normal_statements SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
let_statement    ::=
    LET normal_pattern [let_type_hint] [BIND expression]
  | LET case_pattern BIND expression;
let_type_hint    ::= COLON <<sequence type_expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
type_statement   ::= KW_TYPE identifier [[PROPORTION] type_angle] [BIND type_expr] {
    mixin="com.github.valkyrie.language.mixin.MixinType"
};
// ---------------------------------------------------------------------------------------------------------------------
forall_statement ::= FORALL <<sequence identifier COMMA>> [forall_block];
forall_block     ::= <<brace_block (type_expression COLON type_expression) (COMMA|SEMICOLON)>>;
// ---------------------------------------------------------------------------------------------------------------------
class_statement     ::= KW_CLASS [modifiers] identifier [type_angle] [class_inherit] [class_tuple|class_brace] {
    mixin="com.github.valkyrie.language.mixin.MixinClass"
};
class_inherit       ::= COLON type_instance (OP_ADD type_instance)*;
class_tuple         ::= <<parenthesis class_tuple_item COMMA>>;
class_brace         ::= <<brace_block class_brace_item (COMMA|SEMICOLON)>>;
class_tuple_item    ::= type_expression [BIND expression] {
    mixin="com.github.valkyrie.language.mixin.MixinClassTuple"
};
class_brace_item    ::= (class_numeric_key | modifiers) COLON type_expression [BIND expression] {
    mixin="com.github.valkyrie.language.mixin.MixinClassBrace"
};
class_numeric_key   ::= [modifiers] INTEGER
// ---------------------------------------------------------------------------------------------------------------------
trait_statement     ::= KW_TRAIT modifiers [type_angle] [COLON type_expression] trait_block {
    extends="com.github.valkyrie.language.mixin.MixinTrait"
};
trait_block         ::= <<brace_block normal_statements SEMICOLON>>;
//trait_item        ::= normal_statements;
// ---------------------------------------------------------------------------------------------------------------------
extends_statement   ::= EXTENDS modifiers [[PROPORTION] type_angle] [COLON type_expression] trait_block {
    extends="com.github.valkyrie.language.mixin.MixinExtends"
}
// ---------------------------------------------------------------------------------------------------------------------
tagged_statement    ::= TAGGED modifiers [[PROPORTION] type_angle] tagged_block {
    mixin="com.github.valkyrie.language.mixin.MixinTagged"
};
tagged_block        ::= <<brace_block tagged_item (COMMA|SEMICOLON)>>;
tagged_item         ::= identifier [class_tuple|class_brace];
// ---------------------------------------------------------------------------------------------------------------------
bitflag_statement   ::= BITFLAG modifiers [bitflag_layout] bitflag_block {
    mixin="com.github.valkyrie.language.mixin.MixinBitflag"
};
bitflag_block       ::= <<brace_block (bitflag_item | macro_call) SEMICOLON>>;
bitflag_layout      ::= PARENTHESIS_L type_expression PARENTHESIS_R;
bitflag_item        ::= identifier BIND expression;
// ---------------------------------------------------------------------------------------------------------------------
new_statement       ::= NEW modifiers [type_angle] [COLON type_expression] trait_block;
// ---------------------------------------------------------------------------------------------------------------------
expression          ::= expr (op_binary expr)*;
private expr        ::= op_prefix* term (op_suffix|call_suffix|type_angle|slice_suffix)*;
private term        ::= list | tuple | atoms;
private op_binary   ::= type_binary | ANGLE_L | ANGLE_R | LESS | GREATER | DOT_LESS | DOT_EQ | DOT2 | DOT;
private op_prefix   ::= PLUS | MINUS | NOT | BANG | AMP | DOT3 | DOT2;
private op_suffix   ::= BANG | QUESTION;
call_suffix         ::= <<parenthesis expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
type_expression     ::= type_expr (type_binary type_expr)*;
private type_expr   ::= op_prefix* term (op_suffix|call_suffix|type_angle|slice_suffix)*;
private type_binary ::= VERTICAL | EQ | NE | PLUS | MINUS | TO;
type_angle          ::= OP_PROPORTION? <<generic_block ([identifier COLON] type_expression) COMMA>> OP_PROPORTION?;
type_instance       ::= identifier type_angle?
// ---------------------------------------------------------------------------------------------------------------------
slice_suffix        ::= <<bracket_block slice_expression COMMA>>;
slice_expression    ::=
    [expression] COLON [expression] COLON [expression]
  | [expression] COLON [expression]
  | [expression] PROPORTION [expression]
  | expression;
// ---------------------------------------------------------------------------------------------------------------------
namespace  ::= (macro|identifier) (PROPORTION (macro|identifier))* {
    mixin="com.github.valkyrie.language.mixin.MixinNamepath"
}
macro      ::= AT identifier;
// ---------------------------------------------------------------------------------------------------------------------
macro_call ::= macro [macro_item];
macro_item ::=
    <<parenthesis expression COMMA>>
  | <<brace_block pair COMMA>>
  | <<brace_block expression SEMICOLON>>;
macro_list ::= [AT|HASH] <<bracket_block (namespace macro_item) COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
pair           ::= atoms COLON expression;
list           ::= <<bracket_block expression COMMA>>
tuple          ::= <<parenthesis expression COMMA>>
private atoms  ::= number | string | boolean | namespace;
boolean        ::= "true" | "false";
number         ::= number_literal [identifier];
string         ::= [identifier] STRING_START STRING_TEXT STRING_END {
    mixin="com.github.valkyrie.language.mixin.MixinString"
}
identifier     ::= SYMBOL_XID | SYMBOL_RAW {
    mixin="com.github.valkyrie.language.mixin.MixinIdentifier"
}
number_literal ::= BYTE | INTEGER | DECIMAL;
// ---------------------------------------------------------------------------------------------------------------------
private meta sequence      ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis   ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
private meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
private meta brace_block   ::= BRACE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACE_R;
// angle ::< >::
private meta generic_block ::= GENERIC_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] GENERIC_R;